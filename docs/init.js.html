<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc 4.0.2">
  <meta charset="utf-8">
  <title>pokedex-v2 1.0.4 &raquo; Source: init.js</title>
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Karla:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Noto+Serif:400,400i,700,700i" type="text/css">
  <link rel="stylesheet" href="https://brick.a.ssl.fastly.net/Inconsolata:500" type="text/css">
  <link href="css/baseline.css" rel="stylesheet">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">pokedex-v2 1.<wbr>0.<wbr>4</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: init.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>/**
 * @module
 */
import { get_data_from } from &#x27;./utils.js&#x27;;
import constants from &#x27;./constants.js&#x27;;
import { LevelTrigger, OtherTrigger, TradeTrigger, ItemTrigger, Stats, MoveMeta, DataManagerBase, Item, Species, MoveEffect, StatChange, Move, LevelMethod, PokemonMove, Evolution, EvolutionList, } from &#x27;./models.js&#x27;;
async function get_pokemon(instance) {
    const specie &#x3D; await get_data_from(&#x27;pokemon.csv&#x27;);
    const species &#x3D; specie.reduce((acc, x) &#x3D;&gt; {
        acc[x.id] &#x3D; x;
        return acc;
    }, {});
    const evolutions &#x3D; await get_data_from(&#x27;evolution.csv&#x27;);
    const evolution &#x3D; evolutions.reverse().reduce((acc, x) &#x3D;&gt; {
        acc[x.evolved_species_id] &#x3D; x;
        return acc;
    }, {});
    async function get_evolution_trigger(pid) {
        const evo &#x3D; evolution[String(pid)];
        if (!evo) {
            return;
        }
        if (evo.evolution_trigger_id &#x3D;&#x3D;&#x3D; 1) {
            const level &#x3D; evo.minimum_level || null;
            let item &#x3D; evo.held_item_id || null;
            const move &#x3D; evo.known_move_id || null;
            const movetype &#x3D; evo.known_move_type_id || null;
            const time &#x3D; evo.time_of_day || null;
            const relative_stats &#x3D; evo.relative_physical_stats || null;
            if (evo.location_id) {
                return new OtherTrigger(instance);
            }
            if (evo.minimum_happiness) {
                item &#x3D; 14001;
            }
            return new LevelTrigger(level, item, move, movetype, time, relative_stats, instance);
        }
        if (evo.evolution_trigger_id &#x3D;&#x3D; 2) {
            if (evo.held_item_id) {
                return new TradeTrigger(evo.held_item_id, instance);
            }
            return new TradeTrigger(undefined, instance);
        }
        if (evo.evolution_trigger_id &#x3D;&#x3D; 3) {
            if (evo.trigger_item_id) {
                return new ItemTrigger(evo.trigger_item_id, instance);
            }
            return new OtherTrigger(instance);
        }
        return new OtherTrigger(instance);
    }
    const pokemon &#x3D; {};
    for (const row of Object.values(species)) {
        if (!(&#x27;enabled&#x27; in row)) {
            continue;
        }
        let evo_from &#x3D; null;
        let evo_to &#x3D; null;
        if (row[&#x27;evo.from&#x27;]) {
            const res &#x3D; await get_evolution_trigger(row.id);
            evo_from &#x3D; await Evolution.evolve_from(parseInt(row[&#x27;evo.from&#x27;]), res, instance);
        }
        if (row[&#x27;evo.to&#x27;]) {
            evo_to &#x3D; [];
            for (const s of String(row[&#x27;evo.to&#x27;]).split(&#x27; &#x27;)) {
                if (!s) {
                    continue;
                }
                const pto &#x3D; species[parseInt(s)];
                const res &#x3D; await get_evolution_trigger(pto.id);
                evo_to.push(await Evolution.evolve_to(parseInt(s), res, instance));
            }
        }
        if (evo_to &amp;amp;&amp;amp; evo_to.length &#x3D;&#x3D;&#x3D; 0) {
            evo_to &#x3D; null;
        }
        const types &#x3D; [];
        if (&#x27;type.0&#x27; in row) {
            types.push(row[&#x27;type.0&#x27;]);
        }
        if (&#x27;type.1&#x27; in row) {
            types.push(row[&#x27;type.1&#x27;]);
        }
        const names &#x3D; [];
        if (&#x27;name.ja&#x27; in row) {
            names.push([&#x27;ðŸ‡¯ðŸ‡µ&#x27;, row[&#x27;name.ja&#x27;]]);
        }
        if (&#x27;name.ja_r&#x27; in row) {
            names.push([&#x27;ðŸ‡¯ðŸ‡µ&#x27;, row[&#x27;name.ja_r&#x27;]]);
        }
        if (&#x27;name.en&#x27; in row) {
            names.push([&#x27;ðŸ‡¬ðŸ‡§&#x27;, row[&#x27;name.en&#x27;]]);
        }
        if (&#x27;name.en2&#x27; in row) {
            names.push([&#x27;ðŸ‡¬ðŸ‡§&#x27;, row[&#x27;name.en2&#x27;]]);
        }
        if (&#x27;name.de&#x27; in row) {
            names.push([&#x27;ðŸ‡©ðŸ‡ª&#x27;, row[&#x27;name.de&#x27;]]);
        }
        if (&#x27;name.fr&#x27; in row) {
            names.push([&#x27;ðŸ‡«ðŸ‡·&#x27;, row[&#x27;name.fr&#x27;]]);
        }
        let art_credit &#x3D; row.credit;
        if (art_credit) {
            art_credit &#x3D; &#x27;&#x27;;
        }
        pokemon[row.id] &#x3D; new Species(parseInt(row.id), names, row.slug, new Stats(parseInt(row[&#x27;base.hp&#x27;]), parseInt(row[&#x27;base.atk&#x27;]), parseInt(row[&#x27;base.def&#x27;]), parseInt(row[&#x27;base.satk&#x27;]), parseInt(row[&#x27;base.sdef&#x27;]), parseInt(row[&#x27;base.spd&#x27;])), parseInt(row.height) / 10, parseInt(row.weight) / 10, parseInt(row.dex_number), !!row.catchable, types, parseInt(row.abundance) || 0, parseInt(row.gender_rate) || -1, !!row.has_gender_differences, row.description || null, parseInt(row[&#x27;evo.mega&#x27;]) || null, parseInt(row[&#x27;evo.mega_x&#x27;]) || null, parseInt(row[&#x27;evo.mega_y&#x27;]) || null, evo_from ? new EvolutionList([evo_from]) : null, evo_to ? new EvolutionList(evo_to) : null, !!row.mythical, !!row.legendary, !!row.ultra_beast, !!row.event, !!row.is_form, parseInt(row.form_item) || null, row.region, art_credit, instance, []);
    }
    const moves &#x3D; await get_data_from(&#x27;pokemon_moves.csv&#x27;);
    const version_group &#x3D; {};
    for (const row of moves) {
        version_group[row.pokemon_id] &#x3D; Math.max(version_group[row.pokemon_id] || 0, row.version_group_id);
    }
    for (const row of moves) {
        if (row.pokemon_move_method_id &#x3D;&#x3D;&#x3D; 1 &amp;amp;&amp;amp;
            row.pokemon_id in pokemon &amp;amp;&amp;amp;
            row.version_group_id &#x3D;&#x3D;&#x3D; version_group[row.pokemon_id]) {
            if (!(row.move_id in instance.moves)) {
                continue;
            }
            pokemon[row.pokemon_id].moves.push(new PokemonMove(row.move_id, new LevelMethod(row.level, instance), instance));
        }
    }
    for (const p of Object.values(pokemon)) {
        // @ts-ignore
        p.moves.sort((a, b) &#x3D;&gt; a.method.level - b.method.level);
    }
    return pokemon;
}
async function get_items(instance) {
    const data &#x3D; await get_data_from(&#x27;items.csv&#x27;);
    const items &#x3D; {};
    for (const row of data) {
        items[row.id] &#x3D; new Item(row.id, row.name, row.description || null, row.cost, row.page, row.action, !row.seperate, row.emote || null, !!row.shard, instance);
    }
    return items;
}
async function get_effects(instance) {
    const data &#x3D; await get_data_from(&#x27;move_effect_prose.csv&#x27;);
    const effects &#x3D; {};
    for (const row of data) {
        let description &#x3D; row.short_effect.replace(constants.DESCRIPTION_LINK_REGEX, &#x27;$1&#x27;);
        description &#x3D; description.replace(&#x27;$effect_chance&#x27;, &#x27;{effect_chance}&#x27;);
        effects[row.move_effect_id] &#x3D; new MoveEffect(row.move_effect_id, description, instance);
    }
    return effects;
}
async function get_moves(instance) {
    const data &#x3D; await get_data_from(&#x27;moves.csv&#x27;);
    const name &#x3D; await get_data_from(&#x27;move_names.csv&#x27;);
    const names &#x3D; name
        .filter(x &#x3D;&gt; x.local_language_id &#x3D;&#x3D;&#x3D; 9)
        .reduce((acc, x) &#x3D;&gt; {
        acc[x.move_id] &#x3D; x.name;
        return acc;
    }, {});
    const metas &#x3D; await get_data_from(&#x27;move_meta.csv&#x27;);
    const meta &#x3D; metas.reduce((acc, x) &#x3D;&gt; {
        acc[x.move_id] &#x3D; x;
        return acc;
    }, {});
    const meta_stat &#x3D; await get_data_from(&#x27;move_meta_stat_changes.csv&#x27;);
    const meta_stats &#x3D; meta_stat.reduce((acc, x) &#x3D;&gt; {
        const moveId &#x3D; x.move_id;
        if (!acc[moveId]) {
            acc[moveId] &#x3D; [];
        }
        acc[moveId].push(x);
        delete x.move_id;
        return acc;
    }, {});
    const moves &#x3D; {};
    for (const row of data) {
        if (row.id &gt; 10000) {
            continue;
        }
        const mmeta &#x3D; meta[row.id];
        if (!mmeta) {
            continue;
        }
        delete mmeta.move_id;
        const statchanges &#x3D; meta_stats[row.id]
            ? meta_stats[row.id].map((x) &#x3D;&gt; new StatChange(x.stat_id, x.change))
            : [];
        const { effect_id } &#x3D; row;
        let accuracy &#x3D; row.accuracy || null;
        if (instance.effects[effect_id]?.description
            ?.toLowerCase()
            .includes(&#x27;never misses&#x27;)) {
            accuracy &#x3D; 100;
        }
        moves[row.id] &#x3D; new Move(row.id, row.identifier, names[row.id], row.power || null, row.pp, accuracy, row.priority, row.target_id, row.type_id, row.damage_class_id, effect_id, row.effect_chance || null, new MoveMeta(mmeta.meta_category_id, mmeta.meta_ailment_id, mmeta.drain, mmeta.healing, mmeta.crit_rate, mmeta.ailment_chance, mmeta.flinch_chance, mmeta.stat_chance, mmeta.min_hits, mmeta.max_hits, mmeta.min_turns, mmeta.max_turns, statchanges), instance);
    }
    return moves;
}
class DataManager extends DataManagerBase {
    _isInitialized;
    constructor() {
        super();
        this._isInitialized &#x3D; false;
    }
    async init() {
        this.effects &#x3D; await get_effects(this);
        this.moves &#x3D; await get_moves(this);
        this.pokemon &#x3D; await get_pokemon(this);
        this.items &#x3D; await get_items(this);
        this._isInitialized &#x3D; true;
    }
    checkinitialized() {
        if (!this._isInitialized) {
            throw new Error(&#x27;Pokedex not initialized, call init() first&#x27;);
        }
    }
    toJSON() {
        return {
            pokemonCount: Object.keys(this.pokemon).length,
            itemCount: Object.keys(this.items).length,
            effectCount: Object.keys(this.effects).length,
            moveCount: Object.keys(this.moves).length,
        };
    }
}
export default DataManager;
</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> 4.0.2 on April 27, 2024.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>